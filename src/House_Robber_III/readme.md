# Skills
## Non-adjacent selection
In the context of '198 House Robber' and '213 House Robber II,' the `dp` array signifies the maximum money accumulated from the first house to the current house. However, it doesn't explicitly indicate whether the current house is robbed or skipped. For instance, when referencing `best_robbery[3]`, it represents the maximum value the thief can obtain from the first house to the fourth house without specifying whether the fourth house is robbed or omitted.

In contrast, the 'house_robber_iii_tuple' solution provides a returned tuple that explicitly denotes whether the current house is robbed or skipped. The first output, as generated by the function `rob_or_skip_dfs`, represents the maximum value achievable when the current house is robbed, while the second output corresponds to the maximum value attainable when the current house is skipped.

A significant distinction lies in how the second value (representing the maximum value if the current house is skipped) is calculated. This value accounts for two scenarios:

1. Previous houses have been robbed. 
2. Previous houses have been skipped.
The final result is determined by selecting the maximum value from these possibilities. It's important to note that skipping the current house does not imply that previous houses must have been robbed as well.

To summarize, there are two distinct approaches to address the challenge of non-adjacent house selection:
1. In this approach, the `dp[k]` array denotes the maximum value achievable by the thief from the first house to the `k-th` house. Notably, if the thief opts to skip the current house, the maximum potential value equals to `dp[k - 1]`.
2. The alternative approach employs a 'clear' representation where `dp[k][0]` represents the maximum value the thief obtains by robbing the current house, while `dp[k][1]` signifies the scenario where the current house is skipped. It's important to highlight that in the 'clear' approach, `dp[k][1] = max(dp[k - 1][0], dp[k - 1][1])`.